/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../common";

export type TokenBalanceStruct = {
  token: AddressLike;
  balance: BigNumberish;
  isAllowed: boolean;
  isEnabled: boolean;
};

export type TokenBalanceStructOutput = [
  token: string,
  balance: bigint,
  isAllowed: boolean,
  isEnabled: boolean,
] & { token: string; balance: bigint; isAllowed: boolean; isEnabled: boolean };

export type CreditAccountDataStruct = {
  addr: AddressLike;
  borrower: AddressLike;
  inUse: boolean;
  creditManager: AddressLike;
  underlying: AddressLike;
  borrowedAmountPlusInterest: BigNumberish;
  borrowedAmountPlusInterestAndFees: BigNumberish;
  totalValue: BigNumberish;
  healthFactor: BigNumberish;
  borrowRate: BigNumberish;
  balances: TokenBalanceStruct[];
  repayAmount: BigNumberish;
  liquidationAmount: BigNumberish;
  canBeClosed: boolean;
  borrowedAmount: BigNumberish;
  cumulativeIndexAtOpen: BigNumberish;
  since: BigNumberish;
  version: BigNumberish;
  enabledTokenMask: BigNumberish;
};

export type CreditAccountDataStructOutput = [
  addr: string,
  borrower: string,
  inUse: boolean,
  creditManager: string,
  underlying: string,
  borrowedAmountPlusInterest: bigint,
  borrowedAmountPlusInterestAndFees: bigint,
  totalValue: bigint,
  healthFactor: bigint,
  borrowRate: bigint,
  balances: TokenBalanceStructOutput[],
  repayAmount: bigint,
  liquidationAmount: bigint,
  canBeClosed: boolean,
  borrowedAmount: bigint,
  cumulativeIndexAtOpen: bigint,
  since: bigint,
  version: bigint,
  enabledTokenMask: bigint,
] & {
  addr: string;
  borrower: string;
  inUse: boolean;
  creditManager: string;
  underlying: string;
  borrowedAmountPlusInterest: bigint;
  borrowedAmountPlusInterestAndFees: bigint;
  totalValue: bigint;
  healthFactor: bigint;
  borrowRate: bigint;
  balances: TokenBalanceStructOutput[];
  repayAmount: bigint;
  liquidationAmount: bigint;
  canBeClosed: boolean;
  borrowedAmount: bigint;
  cumulativeIndexAtOpen: bigint;
  since: bigint;
  version: bigint;
  enabledTokenMask: bigint;
};

export type ContractAdapterStruct = {
  allowedContract: AddressLike;
  adapter: AddressLike;
};

export type ContractAdapterStructOutput = [
  allowedContract: string,
  adapter: string,
] & { allowedContract: string; adapter: string };

export type CreditManagerDataStruct = {
  addr: AddressLike;
  underlying: AddressLike;
  pool: AddressLike;
  isWETH: boolean;
  canBorrow: boolean;
  borrowRate: BigNumberish;
  minAmount: BigNumberish;
  maxAmount: BigNumberish;
  maxLeverageFactor: BigNumberish;
  availableLiquidity: BigNumberish;
  collateralTokens: AddressLike[];
  adapters: ContractAdapterStruct[];
  liquidationThresholds: BigNumberish[];
  version: BigNumberish;
  creditFacade: AddressLike;
  creditConfigurator: AddressLike;
  isDegenMode: boolean;
  degenNFT: AddressLike;
  isIncreaseDebtForbidden: boolean;
  forbiddenTokenMask: BigNumberish;
  maxEnabledTokensLength: BigNumberish;
  feeInterest: BigNumberish;
  feeLiquidation: BigNumberish;
  liquidationDiscount: BigNumberish;
  feeLiquidationExpired: BigNumberish;
  liquidationDiscountExpired: BigNumberish;
};

export type CreditManagerDataStructOutput = [
  addr: string,
  underlying: string,
  pool: string,
  isWETH: boolean,
  canBorrow: boolean,
  borrowRate: bigint,
  minAmount: bigint,
  maxAmount: bigint,
  maxLeverageFactor: bigint,
  availableLiquidity: bigint,
  collateralTokens: string[],
  adapters: ContractAdapterStructOutput[],
  liquidationThresholds: bigint[],
  version: bigint,
  creditFacade: string,
  creditConfigurator: string,
  isDegenMode: boolean,
  degenNFT: string,
  isIncreaseDebtForbidden: boolean,
  forbiddenTokenMask: bigint,
  maxEnabledTokensLength: bigint,
  feeInterest: bigint,
  feeLiquidation: bigint,
  liquidationDiscount: bigint,
  feeLiquidationExpired: bigint,
  liquidationDiscountExpired: bigint,
] & {
  addr: string;
  underlying: string;
  pool: string;
  isWETH: boolean;
  canBorrow: boolean;
  borrowRate: bigint;
  minAmount: bigint;
  maxAmount: bigint;
  maxLeverageFactor: bigint;
  availableLiquidity: bigint;
  collateralTokens: string[];
  adapters: ContractAdapterStructOutput[];
  liquidationThresholds: bigint[];
  version: bigint;
  creditFacade: string;
  creditConfigurator: string;
  isDegenMode: boolean;
  degenNFT: string;
  isIncreaseDebtForbidden: boolean;
  forbiddenTokenMask: bigint;
  maxEnabledTokensLength: bigint;
  feeInterest: bigint;
  feeLiquidation: bigint;
  liquidationDiscount: bigint;
  feeLiquidationExpired: bigint;
  liquidationDiscountExpired: bigint;
};

export type PoolDataStruct = {
  addr: AddressLike;
  isWETH: boolean;
  underlying: AddressLike;
  dieselToken: AddressLike;
  linearCumulativeIndex: BigNumberish;
  availableLiquidity: BigNumberish;
  expectedLiquidity: BigNumberish;
  expectedLiquidityLimit: BigNumberish;
  totalBorrowed: BigNumberish;
  depositAPY_RAY: BigNumberish;
  borrowAPY_RAY: BigNumberish;
  dieselRate_RAY: BigNumberish;
  withdrawFee: BigNumberish;
  cumulativeIndex_RAY: BigNumberish;
  timestampLU: BigNumberish;
  version: BigNumberish;
};

export type PoolDataStructOutput = [
  addr: string,
  isWETH: boolean,
  underlying: string,
  dieselToken: string,
  linearCumulativeIndex: bigint,
  availableLiquidity: bigint,
  expectedLiquidity: bigint,
  expectedLiquidityLimit: bigint,
  totalBorrowed: bigint,
  depositAPY_RAY: bigint,
  borrowAPY_RAY: bigint,
  dieselRate_RAY: bigint,
  withdrawFee: bigint,
  cumulativeIndex_RAY: bigint,
  timestampLU: bigint,
  version: bigint,
] & {
  addr: string;
  isWETH: boolean;
  underlying: string;
  dieselToken: string;
  linearCumulativeIndex: bigint;
  availableLiquidity: bigint;
  expectedLiquidity: bigint;
  expectedLiquidityLimit: bigint;
  totalBorrowed: bigint;
  depositAPY_RAY: bigint;
  borrowAPY_RAY: bigint;
  dieselRate_RAY: bigint;
  withdrawFee: bigint;
  cumulativeIndex_RAY: bigint;
  timestampLU: bigint;
  version: bigint;
};

export interface IDataCompressorInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "getAdapter"
      | "getCreditAccountData"
      | "getCreditAccountList"
      | "getCreditManagerData"
      | "getCreditManagersList"
      | "getPoolData"
      | "getPoolsList"
      | "hasOpenedCreditAccount"
      | "version",
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getAdapter",
    values: [AddressLike, AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditAccountData",
    values: [AddressLike, AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditAccountList",
    values: [AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditManagerData",
    values: [AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditManagersList",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolData",
    values: [AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolsList",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "hasOpenedCreditAccount",
    values: [AddressLike, AddressLike],
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(functionFragment: "getAdapter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCreditAccountData",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreditAccountList",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreditManagerData",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreditManagersList",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolData",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolsList",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasOpenedCreditAccount",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
}

export interface IDataCompressor extends BaseContract {
  connect(runner?: ContractRunner | null): IDataCompressor;
  waitForDeployment(): Promise<this>;

  interface: IDataCompressorInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent,
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent,
  ): Promise<this>;

  getAdapter: TypedContractMethod<
    [_creditManager: AddressLike, _allowedContract: AddressLike],
    [string],
    "view"
  >;

  getCreditAccountData: TypedContractMethod<
    [_creditManager: AddressLike, borrower: AddressLike],
    [CreditAccountDataStructOutput],
    "view"
  >;

  getCreditAccountList: TypedContractMethod<
    [borrower: AddressLike],
    [CreditAccountDataStructOutput[]],
    "view"
  >;

  getCreditManagerData: TypedContractMethod<
    [_creditManager: AddressLike],
    [CreditManagerDataStructOutput],
    "view"
  >;

  getCreditManagersList: TypedContractMethod<
    [],
    [CreditManagerDataStructOutput[]],
    "view"
  >;

  getPoolData: TypedContractMethod<
    [_pool: AddressLike],
    [PoolDataStructOutput],
    "view"
  >;

  getPoolsList: TypedContractMethod<[], [PoolDataStructOutput[]], "view">;

  hasOpenedCreditAccount: TypedContractMethod<
    [creditManager: AddressLike, borrower: AddressLike],
    [boolean],
    "view"
  >;

  version: TypedContractMethod<[], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment,
  ): T;

  getFunction(
    nameOrSignature: "getAdapter",
  ): TypedContractMethod<
    [_creditManager: AddressLike, _allowedContract: AddressLike],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCreditAccountData",
  ): TypedContractMethod<
    [_creditManager: AddressLike, borrower: AddressLike],
    [CreditAccountDataStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCreditAccountList",
  ): TypedContractMethod<
    [borrower: AddressLike],
    [CreditAccountDataStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCreditManagerData",
  ): TypedContractMethod<
    [_creditManager: AddressLike],
    [CreditManagerDataStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCreditManagersList",
  ): TypedContractMethod<[], [CreditManagerDataStructOutput[]], "view">;
  getFunction(
    nameOrSignature: "getPoolData",
  ): TypedContractMethod<[_pool: AddressLike], [PoolDataStructOutput], "view">;
  getFunction(
    nameOrSignature: "getPoolsList",
  ): TypedContractMethod<[], [PoolDataStructOutput[]], "view">;
  getFunction(
    nameOrSignature: "hasOpenedCreditAccount",
  ): TypedContractMethod<
    [creditManager: AddressLike, borrower: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "version",
  ): TypedContractMethod<[], [bigint], "view">;

  filters: {};
}
